"""
ReconBuster WAF Detection and Bypass Module
Detects Web Application Firewalls and suggests bypass techniques
"""

import asyncio
import aiohttp
import re
import random
from typing import List, Dict, Optional, Callable, Tuple
from dataclasses import dataclass, field
from urllib.parse import urlparse
from datetime import datetime
from .utils import AsyncHTTPClient, normalize_url, USER_AGENTS


@dataclass
class WAFResult:
    """WAF detection result"""
    detected: bool
    waf_name: str = ""
    confidence: str = ""  # high, medium, low
    evidence: List[str] = field(default_factory=list)
    bypass_techniques: List[str] = field(default_factory=list)
    headers_found: Dict[str, str] = field(default_factory=dict)
    timestamp: str = field(default_factory=lambda: datetime.now().isoformat())


class WAFDetector:
    """
    Web Application Firewall Detector
    Identifies WAF/IPS presence and suggests bypass techniques
    """

    # WAF Signatures - Headers, Cookies, Response patterns
    WAF_SIGNATURES = {
        "Cloudflare": {
            "headers": ["cf-ray", "cf-cache-status", "__cfduid", "cf-request-id"],
            "cookies": ["__cfduid", "cf_clearance"],
            "response": ["cloudflare", "attention required", "cf-ray"],
            "server": ["cloudflare"],
        },
        "AWS WAF": {
            "headers": ["x-amzn-requestid", "x-amz-cf-id", "x-amz-id-2"],
            "cookies": ["awsalb", "awsalbcors"],
            "response": ["aws", "amazon"],
            "server": ["awselb", "amazons3"],
        },
        "Akamai": {
            "headers": ["akamai-origin-hop", "x-akamai-transformed"],
            "cookies": ["akamai", "ak_bmsc", "bm_sv"],
            "response": ["akamai", "reference #"],
            "server": ["akamaighost", "akamai"],
        },
        "Imperva/Incapsula": {
            "headers": ["x-cdn", "x-iinfo"],
            "cookies": ["incap_ses", "visid_incap", "nlbi_"],
            "response": ["incapsula", "incident id"],
            "server": ["imperva", "incapsula"],
        },
        "Sucuri": {
            "headers": ["x-sucuri-id", "x-sucuri-cache"],
            "cookies": ["sucuri_cloudproxy"],
            "response": ["sucuri", "cloudproxy", "access denied - sucuri"],
            "server": ["sucuri"],
        },
        "ModSecurity": {
            "headers": ["mod_security", "modsecurity"],
            "cookies": [],
            "response": ["mod_security", "modsecurity", "this error was generated by mod_security"],
            "server": ["mod_security"],
        },
        "F5 BIG-IP": {
            "headers": ["x-wa-info", "x-cnection"],
            "cookies": ["bigipserver", "ts", "f5_cspm"],
            "response": ["the requested url was rejected", "f5 networks"],
            "server": ["bigip", "f5"],
        },
        "Barracuda": {
            "headers": ["barra_counter_session"],
            "cookies": ["barra_counter_session"],
            "response": ["barracuda", "your request has been blocked"],
            "server": ["barracuda"],
        },
        "Fortinet FortiWeb": {
            "headers": ["fortiwafsid"],
            "cookies": ["cookiesession1"],
            "response": ["fortigate", "fortinet", "fortiweb"],
            "server": ["fortigate", "fortiweb"],
        },
        "Citrix NetScaler": {
            "headers": ["cneonction", "x-client-ip", "citrix"],
            "cookies": ["ns_af", "citrix_ns_id", "nsc_"],
            "response": ["ns.conf", "citrix", "netscaler"],
            "server": ["citrix", "netscaler"],
        },
        "DenyAll": {
            "headers": [],
            "cookies": ["sessioncookie"],
            "response": ["denyall", "conditioned by"},
            "server": ["denyall"],
        },
        "Wordfence": {
            "headers": [],
            "cookies": ["wfwaf-authcookie"],
            "response": ["wordfence", "this response was generated by wordfence"],
            "server": [],
        },
        "Comodo": {
            "headers": [],
            "cookies": [],
            "response": ["protected by comodo", "comodo waf"],
            "server": ["comodo"],
        },
        "StackPath": {
            "headers": ["x-sp-url", "x-sp-edge-host"],
            "cookies": [],
            "response": ["stackpath"],
            "server": ["stackpath"],
        },
        "Fastly": {
            "headers": ["x-fastly-request-id", "fastly-debug-digest"],
            "cookies": [],
            "response": ["fastly error"],
            "server": ["fastly"],
        },
        "KeyCDN": {
            "headers": ["x-edge-location"],
            "cookies": [],
            "response": [],
            "server": ["keycdn"],
        },
        "Nginx (Lua WAF)": {
            "headers": [],
            "cookies": [],
            "response": ["openresty", "lua-resty-waf"],
            "server": ["openresty", "nginx-lua"],
        },
        "AWS CloudFront": {
            "headers": ["x-amz-cf-id", "x-amz-cf-pop"],
            "cookies": [],
            "response": ["cloudfront"],
            "server": ["cloudfront"],
        },
        "Wallarm": {
            "headers": ["x-wallarm-waf-check"],
            "cookies": [],
            "response": ["wallarm"],
            "server": ["wallarm"],
        },
        "Reblaze": {
            "headers": ["rbzid"],
            "cookies": ["rbzid", "rbzreqid"],
            "response": ["reblaze"],
            "server": ["reblaze"],
        },
        "Radware": {
            "headers": ["x-rdwr", "rdwr"],
            "cookies": [],
            "response": ["radware", "defensepr"],
            "server": ["radware"],
        },
        "SiteLock": {
            "headers": [],
            "cookies": [],
            "response": ["sitelock"],
            "server": ["sitelock"],
        },
        "PerimeterX": {
            "headers": [],
            "cookies": ["_px", "_pxhd"],
            "response": ["perimeterx", "press & hold"],
            "server": [],
        },
        "DataDome": {
            "headers": [],
            "cookies": ["datadome"],
            "response": ["datadome"],
            "server": [],
        },
        "Shape Security": {
            "headers": [],
            "cookies": [],
            "response": ["shape security"],
            "server": ["shape"],
        },
    }

    # WAF Bypass Techniques
    WAF_BYPASS_TECHNIQUES = {
        "Cloudflare": [
            "Use Cloudflare bypass services (find origin IP)",
            "Try IP-based access if origin IP is known",
            "Use HTTP/2 protocol",
            "Encode payloads with double URL encoding",
            "Use Unicode normalization bypass",
            "Try bypassing via Tor or different IPs",
        ],
        "AWS WAF": [
            "Use case variation in payloads",
            "Try Unicode/UTF-8 encoding",
            "Use comment insertion in payloads",
            "Parameter pollution techniques",
            "Chunked transfer encoding",
        ],
        "ModSecurity": [
            "Use comment blocks in SQL: /*!50000..*/",
            "Try null bytes: %00",
            "HPP (HTTP Parameter Pollution)",
            "Use alternative encodings",
            "Try whitespace alternatives: %0a, %0d, %09",
        ],
        "Imperva/Incapsula": [
            "Unicode character substitution",
            "Case manipulation",
            "Encoding chains (URL + HTML)",
            "Parameter fragmentation",
        ],
        "generic": [
            "Double URL encoding: %252f instead of /",
            "Unicode encoding: %u002f",
            "Mixed case: SeLeCt instead of select",
            "Comment insertion: SEL/**/ECT",
            "Null bytes: %00",
            "Tab/newline substitution: %09, %0a",
            "HPP (HTTP Parameter Pollution)",
            "JSON/XML content type switch",
            "HTTP method tampering",
            "Chunked transfer encoding",
            "HTTP/2 specific bypasses",
            "IPv6 address format",
        ]
    }

    # Attack payloads to trigger WAF
    TRIGGER_PAYLOADS = [
        # XSS triggers
        "<script>alert(1)</script>",
        "<img src=x onerror=alert(1)>",
        "javascript:alert(1)",

        # SQLi triggers
        "' OR '1'='1",
        "1' AND '1'='1",
        "1 UNION SELECT NULL--",

        # LFI triggers
        "../../etc/passwd",
        "..%2f..%2fetc/passwd",
        "/etc/passwd%00",

        # Command injection
        "; cat /etc/passwd",
        "| ls -la",

        # Path traversal
        "....//....//etc/passwd",
    ]

    def __init__(self, target: str, callback: Callable = None, timeout: int = 10):
        self.target = normalize_url(target)
        self.callback = callback
        self.timeout = timeout
        self.results: List[WAFResult] = []

    async def emit(self, event: str, data: dict):
        if self.callback:
            await self.callback(event, data)

    async def detect(self) -> WAFResult:
        """Main WAF detection method"""
        await self.emit("status", {"message": "Starting WAF detection..."})

        waf_result = WAFResult(detected=False)
        evidence = []

        # Method 1: Check normal response headers
        headers_waf = await self._check_headers()
        if headers_waf:
            waf_result.detected = True
            waf_result.waf_name = headers_waf["name"]
            evidence.extend(headers_waf["evidence"])
            waf_result.headers_found = headers_waf.get("headers", {})

        # Method 2: Check cookies
        cookies_waf = await self._check_cookies()
        if cookies_waf:
            waf_result.detected = True
            if not waf_result.waf_name:
                waf_result.waf_name = cookies_waf["name"]
            evidence.extend(cookies_waf["evidence"])

        # Method 3: Trigger WAF with malicious payloads
        triggered_waf = await self._trigger_waf()
        if triggered_waf:
            waf_result.detected = True
            if not waf_result.waf_name:
                waf_result.waf_name = triggered_waf["name"]
            evidence.extend(triggered_waf["evidence"])

        waf_result.evidence = list(set(evidence))

        # Set confidence level
        if len(evidence) >= 3:
            waf_result.confidence = "high"
        elif len(evidence) >= 2:
            waf_result.confidence = "medium"
        elif len(evidence) >= 1:
            waf_result.confidence = "low"

        # Get bypass techniques
        if waf_result.waf_name:
            waf_result.bypass_techniques = self.WAF_BYPASS_TECHNIQUES.get(
                waf_result.waf_name,
                self.WAF_BYPASS_TECHNIQUES["generic"]
            )
        elif waf_result.detected:
            waf_result.bypass_techniques = self.WAF_BYPASS_TECHNIQUES["generic"]

        await self.emit("waf_detection_complete", waf_result.__dict__)
        return waf_result

    async def _check_headers(self) -> Optional[Dict]:
        """Check response headers for WAF signatures"""
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(
                    self.target,
                    timeout=aiohttp.ClientTimeout(total=self.timeout),
                    ssl=False,
                    headers={"User-Agent": random.choice(USER_AGENTS)}
                ) as resp:
                    headers = {k.lower(): v for k, v in resp.headers.items()}
                    server = headers.get("server", "").lower()

                    for waf_name, signatures in self.WAF_SIGNATURES.items():
                        evidence = []

                        # Check headers
                        for sig_header in signatures["headers"]:
                            if sig_header.lower() in headers:
                                evidence.append(f"Header found: {sig_header}")

                        # Check server header
                        for sig_server in signatures["server"]:
                            if sig_server.lower() in server:
                                evidence.append(f"Server header: {server}")

                        if evidence:
                            return {
                                "name": waf_name,
                                "evidence": evidence,
                                "headers": dict(headers)
                            }

        except Exception:
            pass

        return None

    async def _check_cookies(self) -> Optional[Dict]:
        """Check cookies for WAF signatures"""
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(
                    self.target,
                    timeout=aiohttp.ClientTimeout(total=self.timeout),
                    ssl=False
                ) as resp:
                    cookies = {k.lower(): v.value for k, v in resp.cookies.items()}

                    for waf_name, signatures in self.WAF_SIGNATURES.items():
                        evidence = []

                        for sig_cookie in signatures["cookies"]:
                            for cookie_name in cookies.keys():
                                if sig_cookie.lower() in cookie_name:
                                    evidence.append(f"Cookie found: {cookie_name}")

                        if evidence:
                            return {"name": waf_name, "evidence": evidence}

        except Exception:
            pass

        return None

    async def _trigger_waf(self) -> Optional[Dict]:
        """Try to trigger WAF with attack payloads"""
        for payload in self.TRIGGER_PAYLOADS[:5]:
            try:
                test_url = f"{self.target}?test={payload}"

                async with aiohttp.ClientSession() as session:
                    async with session.get(
                        test_url,
                        timeout=aiohttp.ClientTimeout(total=self.timeout),
                        ssl=False,
                        headers={"User-Agent": random.choice(USER_AGENTS)}
                    ) as resp:
                        status = resp.status
                        content = await resp.text()
                        content_lower = content.lower()

                        # Check if blocked
                        if status in [403, 406, 429, 503]:
                            # Look for WAF signatures in response
                            for waf_name, signatures in self.WAF_SIGNATURES.items():
                                for sig in signatures["response"]:
                                    if sig.lower() in content_lower:
                                        return {
                                            "name": waf_name,
                                            "evidence": [f"Blocked response with '{sig}'"]
                                        }

                            return {
                                "name": "Unknown WAF",
                                "evidence": [f"Request blocked with status {status}"]
                            }

            except Exception:
                pass

        return None

    async def test_bypass(self, technique: str) -> bool:
        """Test a specific bypass technique"""
        # Implementation would vary based on technique
        pass


class WAFBypass:
    """
    Advanced WAF Bypass Techniques
    """

    # Encoding functions
    @staticmethod
    def url_encode(payload: str) -> str:
        """Single URL encoding"""
        from urllib.parse import quote
        return quote(payload, safe='')

    @staticmethod
    def double_url_encode(payload: str) -> str:
        """Double URL encoding"""
        from urllib.parse import quote
        return quote(quote(payload, safe=''), safe='')

    @staticmethod
    def unicode_encode(payload: str) -> str:
        """Unicode encoding"""
        return ''.join(f'%u{ord(c):04x}' for c in payload)

    @staticmethod
    def html_encode(payload: str) -> str:
        """HTML entity encoding"""
        return ''.join(f'&#{ord(c)};' for c in payload)

    @staticmethod
    def hex_encode(payload: str) -> str:
        """Hex encoding"""
        return ''.join(f'\\x{ord(c):02x}' for c in payload)

    @staticmethod
    def case_swap(payload: str) -> str:
        """Random case swapping"""
        return ''.join(
            c.upper() if random.random() > 0.5 else c.lower()
            for c in payload
        )

    @staticmethod
    def comment_injection_sql(payload: str) -> str:
        """SQL comment injection"""
        keywords = ['SELECT', 'UNION', 'FROM', 'WHERE', 'AND', 'OR']
        for kw in keywords:
            payload = payload.replace(kw, f'{kw[0]}/**/{"".join(kw[1:])}')
        return payload

    @staticmethod
    def null_byte_injection(payload: str) -> str:
        """Null byte injection"""
        return payload + '%00'

    @staticmethod
    def newline_injection(payload: str) -> str:
        """Newline injection"""
        return payload.replace(' ', '%0a')

    @staticmethod
    def tab_injection(payload: str) -> str:
        """Tab injection"""
        return payload.replace(' ', '%09')

    @staticmethod
    def generate_bypass_payloads(original_payload: str) -> List[str]:
        """Generate multiple bypass variants of a payload"""
        bypasses = [
            WAFBypass.url_encode(original_payload),
            WAFBypass.double_url_encode(original_payload),
            WAFBypass.unicode_encode(original_payload),
            WAFBypass.html_encode(original_payload),
            WAFBypass.case_swap(original_payload),
            WAFBypass.null_byte_injection(original_payload),
            WAFBypass.newline_injection(original_payload),
            WAFBypass.tab_injection(original_payload),
        ]

        # SQL specific
        if any(kw in original_payload.upper() for kw in ['SELECT', 'UNION', 'WHERE']):
            bypasses.append(WAFBypass.comment_injection_sql(original_payload))

        return list(set(bypasses))
